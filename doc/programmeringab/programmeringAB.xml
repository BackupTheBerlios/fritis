<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "/usr/share/sgml/docbook/dtd/4.2/docbookx.dtd" [
<!ENTITY fdl-sv SYSTEM "fdl-sv.xml">
<!ENTITY dtr1207 SYSTEM "dtr1207.xml">
<!ENTITY dtr1208 SYSTEM "dtr1208.xml">
]>

<book lang="sv">
<bookinfo>

	<title>Programmering i PHP</title>
	
	<authorgroup>
	<author>
		<firstname>Marcus</firstname>
		<surname>Rejås</surname>
		<affiliation>
			<address>
				<email>marcus@rejas.se</email>
			</address>
		</affiliation>
	</author>
	<author>
		<firstname>Magnus</firstname>
		<surname>Määttä</surname>
		<affiliation>
			<address>
				<email>magnus@php.net</email>
			</address>
		</affiliation>
	</author>
	</authorgroup>

	<pubdate>November 2003</pubdate>

	<copyright>
		<year>2003</year>
		<holder>Marcus Rejås och Magnus Määttä</holder>
	</copyright>

	<legalnotice>
		<para>
			Var och en äger rätt att kopiera, distribuera och/eller
			modifiera detta dokument under villkoren i licensen "GNU Free
			Documentation License", version 1.2 eller senare publicerad av
			Free Software Foundation, med de invarianta avsnitten <xref
			linkend="dtr1207"/> och <xref linkend="dtr1208"/>, utan
			framsidestexter och utan baksidestexter.  En kopia av denna
			licens finns med i avsnittet med titeln "GNU Free Documentation
			License".
		</para>

		<para>
			Det vill säga, du kan fritt ladda ner, vidaredistribuera
			och kopiera denna bok. Du får ändra den om du vill (se
			licenstexten).  Tryckta böcker kan köpas av TriNix AB i
			Helsingborg, telefon 042-127800.
		</para>
	</legalnotice>

	<revhistory>
		<revision>
			<revnumber>$Id: programmeringAB.xml,v 1.9 2004/01/08 19:12:27 magnus Exp $</revnumber>
			<date></date>
			<revremark>*** Utvecklingsversion ***</revremark>
		</revision>
	</revhistory>

	<abstract>
		<para>
			Denna bok är anpassad för gymnasieskolans kurser
			Programmering A och B med kurskoderna DTR1207 och
			DTR1208 (PPHP1408). Den kan naturligtvis användas även i
			andra sammanhang, till exempel självstudier,
			studiecirklar eller annan lärarledd utbildning.
		</para>

		<para>
			Till boken kommer att finnas förslag på övningar man kan
			utföra för att praktiskt utöva de färdigheter man
			skaffar sig under studierna.
		</para>
	</abstract>
</bookinfo>

<toc/>

<chapter>
	<title>Kort historik</title>


	<sect1>
		<title>Före 1900</title>

		<para>
			Man började faktiskt att utveckla den metodiken som används i
			dagens datorer redan på 1800-talet. Den första kalkylatorn som
			räknade digitalt uppfann och byggde engelsmannen Charles Babbage
			1832!  Den opererade på sexsiffriga nummer och kunde lösa
			andragradspolynom med sex siffrors noggrannhet. Efter denna maskin
			började Babbage på en ännu större maskin, the analytical engine.
			Denna uppgift lyckades han aldrig lösa. Idag vet vi varför, det var en
			enorm uppgift som inte gick att lösa med dåtidens kunskaper och
			verktyg.  Babbage dog i 1871. Då var det inte många som visste vem
			han var men nu nämns han i varenda kurs som innefattar
			datorhistoria världen över.
		</para>

		<para>
			Mycket mer saker händer under 1800-talet. Men vi hoppar direkt till
			1900-talet.
		</para>
	</sect1>

	<sect1>
		<title>1900-talet</title>

		<para>
			1936 skrev Alan Turing en rapport som beskriver hur en digital
			dator skulle fungera. Rapporten beskrev hur programmen skulla
			lagras och köras. Dessa kom sedan att kallas Turing-maskiner.
		</para>

		<para>
			1941 blev den första fungerande turingmaskinen klar. Den skapades
			av Konrad Zuse. Den var fritt programmerbar och helautomatisk.
			Den hade en klockfrekvens på 5.33 Hz och vad byggd med reläer. Det
			dröjde några år till innan datorerna blev elektroniska.
		</para>

		<para>
			Den första moderna datorn blev en maskin som hette ENIAC. Den stod
			klar 1946. ENIAC är en förkorting för Electronic Numerical Integrator
			And Computer. Den var stor som ett hus (18000 elektronrör) och kunde
			mindre än den enklaste kalkylator kan idag. En som var inblandad i
			utvecklingen av ENIAC var John von Neumann. Von Neumann skapade en
			datorarkitektur, von Neumann-arkitekturen, som datorer än idag byggs
			efter. Det var den första arkitekturen där beräkningsenhet och minne
			var separerade. Mellan dem fanns det en buss över vilken data och
			instruktioner transporterades. Von Neumann anses av många vara den
			moderna datorns fader.
		</para>
	</sect1>

	<sect1>
		<title>Nutid</title>
		<para>
			Utvecklingen står på intet sätt still. Datorerna utvecklas ständigt.
			Varje år blir datorerna snabbare och billigare. Det lär dock dröja
			ett tag innan något så revolutionerande som Babbages kalkylator eller
			ENIAC ser dagens ljus. Sen hur lång tid det tar, det återstår att se.
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>
		<para>
			På adressen
			<ulink url="http://www2.fht-esslingen.de/studentisches/Computer_Geschichte/fold1.html">
				<citetitle>
					http://www2.fht-esslingen.de/studentisches/Computer_Geschichte/fold1.html
				</citetitle>
			</ulink>
			finns en bra tidslinje för datorns historia.
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Programmeringsspråk</title>

	<abstract>
		<para>
			Detta avsnitt ger en orientering om olika
			programmeringsspråk och varför det finns så många och
			några grundläggande egenskaper hos olika språk och olika
			familjer av språk.
		</para>
	</abstract>

	<sect1>
		<title>Olika språk till olika saker</title>

		<para>
			Det finns idag hundratals olika programmeringsspråk. De har kommit
			till av olika anledningar och har olika syften. Vissa är besläktade
			och har arv från varandra och andra har utvecklats för att fylla ett
			speciellt ändamål.
		</para>

		<para>
			Anledningen till att det finns så många språk och alltid kommer nya
			är naturligtvis att de är bra på olika saker och att olika personer
			uppskattar språken olika mycket.
		</para>

		<para>
			Vi kan börja med att dela upp språken i två grupper efter hur
			programmen kompileras och körs. Alla program skrivs i någon form av
			källkod. Denna källkod måste sedan översättas till något som en dator
			kan förstå. Datorn förstår bara 1 och 0, på eller av. Detta kallas
			kompilering och kan göras vid olika tillfällen.
		</para>
	</sect1>

	<sect1>
		<title>Kompilerande språk</title>

		<para>
			Datorn kan ju inte läsa utan det som man skriver i sina program måste
			översättas till något som datorn förstår. Det datorn förstår kallas
			för maskinkod eller binärkod. Denna kod består av maskininstruktioner
			som är, näst intill, omöjliga för en människa att förstå.
		</para>

		<para>
			Ett kompilerande språk är ett programmeringsspråk där källkoden med
			hjälp av olika verktyg översätts till maskinkod. Maskinkoden blir då
			ett fristående program som kan köras direkt av datorn. Man säger att
			man kompilerar koden. Koden kopileras alltså i samband med
			utvecklingen och inte i samband med exekveringen av programmet. Mer
			om det i ett annat avsnitt.
		</para>

		<para>
			Exempel på kompilerande språk är: C, C++, Pascal och många fler.
		</para>
	</sect1>

	<sect1>
		<title>Interpreterande språk</title>

		<para>
			Ett interpreterande programspråk, som också kallas skriptspråk, är
			ett programspråk som inte kompilerar det program som programmeraren
			har skrivit förrän det körs, och som gör det varje gång det körs.
			Ibland kompileras hela programmet innan det körs och ibland
			kompileras det rad för rad. Detta gör att utvecklingen går snabbare
			eftersom programmet inte behöver kompileras vid testkörning men det
			innebår också att det färdiga programmet blir långsammare eftersom
			det måste kompileras varje gång det körs.
		</para>

		<para>
			Motorn som kör ett interpreterande språk kallas interpretator,
			programtolk eller tolkare.
		</para>

		<para>
			Exempel på interpreterande språk är: Perl, PHP, Python, TCL, Bash.
		</para>
	</sect1>

	<sect1>
		<title>Andra typer av språk</title>

		<para>
			Det finns andra sätt att lösa uppgiften på. Till exempel att man
			kompilerar koden till en mellankod som sedan en interpreterare
			tolkar. Så fungerar till exempel Java.
		</para>
	</sect1>

	<sect1>
		<title>För- och nackdelar</title>

		<table frame='all'>
			<title>
				Fördeler och nackdelar med kompilerande och interpreterande språk.
			</title>

			<tgroup cols='2' align='left' colsep='3' rowsep='3'>
				<colspec colname='c1'/>
				<colspec colname='c2'/>
				<thead>
					<row>
						<entry>Fördelar</entry>
						<entry>Nackdelar</entry>
					</row>
				</thead>
				<tbody>
					<row>
					<entry namest="c1" nameend="c2" align="center">
						Kompilerande
					</entry>
					</row>
					<row>
						<entry>Snabbt att köra</entry>
						<entry>Långsam programmering</entry>
					</row>
					<row>
						<entry>Lätt att distribuera</entry>
						<entry>Svårt att portera</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center">
							Interpreterande
						</entry>
					</row>
					<row>
						<entry>Långsamt att köra</entry>
						<entry>Snabb programmering</entry>
					</row>
					<row>
						<entry>
							Mycket lätt att portera (om tolkare finns)
						</entry>
						<entry>
							Svårare att distribuera (tolkare måste finnas)
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	</sect1>

	<sect1>
		<title>Exempel på olika språk som ni bör känna till</title>

		<para>
			Det finns tusentals, jo säkert, olika programmeringsspråk. Här
			listas de jag tycker ni bör känna till och hur programmet
			"Hello World!" ser ut i dem.
		</para>

		<sect2>
			<title>C</title>
			<para>
				C är ett av de mest utbredda språken. Det är en vidareutveckling
				av språket B. Utvecklades vid AT&amp;T Bell Labs samtidigt med
				operativsystemet UNIX. C anses som ett ganska maskinnära språk.
				Flera operativsystem är till stor det skrivna i C. Hello World
				i C ser ut så här:
			</para>

			<para>
				<example>
					<title>Hello World i C</title>
					<programlisting>
<![CDATA[
/*
 * Hello World i C
 */
#include <stdio.h>

int main() {
        printf("Hello, world!\n");
        return 0;
}
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>C++</title>

			<para>
				C++ utveckladen av Bjarne Stroustrup vid AT&amp;T Bell Labs och
				är en utökning av programspråket C. Till skillnad från C så är
				C++ objektorienterat (eller har bättre stöd för det i alla fall).
			</para>

			<para>
				Hello World i C++ ser ut så här:
			</para>

			<para>
				<example>
					<title>Hello World i C++</title>
					<programlisting>
<![CDATA[
/*
 * Hello World i C++
 */
#include <iostream>

int main () {
        cout << "Hello world" << endl;
}
]]>
					</programlisting>
				</example>
			</para>
		</sect2>
		<sect2>
			<title>C# (C-sharp eller Ciss)</title>

			<para>
				Objektorienterat språk utvecklat av Microsoft för att möta Java
				från Sun. Språket är, liksom Java, halvinterpreterande och har
				mycket influenser från C och C++.
			</para>

			<para>
				Hello World i C# ser ut så här:
				<example>
					<title>Hello World i C#</title>
					<programlisting>
<![CDATA[
//
// Hello World i C#
//
using System;
class HelloWorld {
        static void Main() {
                Console.WriteLine("Hello, world!");
        }
}
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>Java</title>
			<para>
				Objektorienterat språk utvecklat av Sun Microsystems. Språket är
				halvinterpreterande och har mycket influenser från C och C++. En
				stor fördel med Java är att program skrivna i Java är nästan
				platformsoberoende. Du kan alltså köra dem i alla miljöer till
				vilka det finns en javamotor.
			</para>

			<para>
				Hello World i Java ser ut så här:
				<example>
					<title>Hello World i Java</title>
					<programlisting>
<![CDATA[
//
// Hello World i Java
//
class HelloWorld {
        public static void main (String s[]) {
                System.out.println("Hello world");
        }
}
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>Mer läsning</title>
			<para>
				En sida med jättemånga exempel på "Hello World!" i olika språk. (
				<ulink url="http://www2.latech.edu/~acm/HelloWorld.shtml">
					<citetitle>
						http://www2.latech.edu/~acm/HelloWorld.shtml
					</citetitle>
				</ulink>
				)
			</para>
		</sect2>
	</sect1>
</chapter>

<chapter>
	<title>Från källkod till program</title>
	<abstract>
		<para>
			I detta avsnitt beskrivs vad en kompilator är och varför den
			används. Detta ingår i kursen men används inte i PHP eftersom det
			är ett så kallat skriptspråk. I fallet med PHP tar en tolkare hand om
			allt detta på servern när programmet körs.
		</para>
	</abstract>

	<sect1>
		<title>Kompilering</title>

		<para>
			När man "kompilerar" ett program så utför man egentligen 3 steg.
			Ett fjärde steg utförs precis innan programmet laddas för att
			köras. Dessa steg behandlar vi här.
		</para>

		<para>
			Stegen är förbehandling av källkoden, kompilering, assemblering
			och slutligen länkning. Dessa steg behandlas här.
		</para>

		<sect2>
			<title>Förbehandling av källkoden (preprocessing)</title>

			<para>
				Det första som händer med din källkod är att den går igenom
				något som kallas en preprocessor. Den tar bort alla
				kommentarer, som ju i alla fall bara betyder något för
				människor och formaterar din kod så att den passar
				kompilatorn.
			</para>
		</sect2>

		<sect2>
			<title>Kompilering</title>

			<para>
				Sedan är det kompilatorns tur. Det översätter källkoden till
				ett mellanspråk anpassat för den målmiljö som man kompilerar
				för. Detta mellanspråk kallas assembler och skall sedan
				behandlas av en assemblerare.
			</para>
		</sect2>

		<sect2>
			<title>Assemblering</title>

			<para>
				Assemleraren översätter assemblrerkoden till maskinkod. Denna
				kod är relokerbar, det vill säga den är inte bunden till
				fasta adresser i minnet. Dessa relokerbara adresser måste
				dock ändras innan programmet kan köras, det gör laddaren
				(loader).
			</para>
		</sect2>

		<sect2>
			<title>Laddning och länkning</title>

			<para>
				Detta är egentligen två steg men de görs nästan alltid
				tillsammans och de görs varje gång programmet skall köras.
				De görs oftast av samma rutin. Laddning innebär att
				programmet flyttas till ett ställe i minnet där det kan
				köras och se till att adresserna i programmet anpassas efter
				det ställe det skall köras. Länkaren behöver bara jobba om
				det körbara programmet behöver delar från flera olika filer,
				så kallade delade bibliotek (shared libraries, dll:er).
				Länkaren ser då till att hänvisningarna till dessa i
				programmet blir riktiga och kontrollerar att de finns
				tillgängliga.
			</para>
		</sect2>

		<sect2>
			<title>Mer läsning</title>
			<para>
				Om du är intresserad kan du läsa denna länk
				<ulink url="http://techpubs.sgi.com/library/dynaweb_docs/0620/SGI_Developer/books/Pascal_PG/sgi_html/ch02.html">
					<citetitle>
						http://techpubs.sgi.com/library/dynaweb_docs/0620/SGI_Developer/books/Pascal_PG/sgi_html/ch02.html
					</citetitle>
				</ulink>
				där kompileringen i Pascal beskrivs mer ingående.
			</para>
		</sect2>
	</sect1>
</chapter>

<chapter>
	<title>Hallå Världen!</title>

	<abstract>
		<para>
			Detta avsnitt beskriver hur ett enkelt PHP-script är uppbyggt.
		</para>
	</abstract>


	<sect1>
		<title>Programmeringsmiljön</title>
		<para>
			Som vi har sagt tidigare så skapar man ett program på följande
			sätt (något förenklat):

			<itemizedlist>
				<listitem><para>Skapa PHP-fil</para></listitem>
				<listitem><para>Kopiera till servern</para></listitem>
				<listitem><para>Provkör</para></listitem>
			</itemizedlist>
		</para>

		<para>
			Du kan använda vilken editor du vill för att skapa php-filer.
			Notepad fungerar alldeles utmärkt men det finns de med fler
			finesser. Vim är en av dem. Den har stöd bland annat för
			färgläggning av kod och finns för både Linux och Windows att hämta
			från deras hemsida:
			<ulink url="http://vim.sf.net">
				<citetitle>
					http://vim.sf.net
				</citetitle>
			</ulink>
		</para>
	</sect1>

	<sect1>
		<title>Hallå världen!</title>

		<para>
			Nästan alla programmeringskurser börjar med att man skapar ett
			program som heter Hello World. Hello World är ett program som
			inte gör något annat än att skriva ut "Hello World" på skärmen.
		</para>

		<para>
			Vi börjar med att titta på hur det ser ut i PHP.
			<example>
				<title>Hello World i PHP</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Hallå Världen!</title>
</head>
<body>
   <p>
      <?php
         echo "Hallå Världen!";
      ?>
   </p>
</body>
</html>
]]>
				</programlisting>
			</example>
		</para>

		<para>
			Så, vad gör nu detta program? Som ni säkert kan se så är det HTML
			i början och slutet av filen. Det enda av filen som är PHP är
			mellan tecknen &lt;?php och ?&gt;. Det är för att tolkaren skall
			veta när den skall exekvera raderna istället för att skriva ut dem.
		</para>

		<para>
			Den enda PHP-koden i detta lilla program är
			<type>echo "Hallå Världen!";</type>. Echo talar om att något skall
			skrivas ut (Hallå Världen!) och semikolonet talar om att en sats i
			programmet slutar. En sats kan omfatta flera rader men avslutas
			alltid av ett semikolon.
		</para>

		<para>
			Man kan självklart skriva ett "Hello World!" program som enbart
			använder sig av PHP och ingen HTML (dock utan den formatering som
			kommer med HTML).
			<example>
				<title>Hello World i PHP utan HTML</title>
				<programlisting>
<![CDATA[
<?php
echo "Hallå Världen!";
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Övningsuppgifter</title>
		<para>
			<itemizedlist>
				<listitem>
					<para>
						Ändra programmet så att det skriver ut något annat än
						"Hallå Världen!". Testa att det fungerar som du vill.
					</para>
				</listitem>

				<listitem>
					<para>
						Gör så att två rader skrivs ut. (Använd HTML-koder).
					</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Webbrowser, webbserver och program</title>

	<abstract>
		<para>
			När man skriver och kör ett PHP-program är det många delar som
			skall samverka. Man skriver ett program som skall tolkas av en
			PHP-tolk. Sedan skall utdata av detta program hanteras av en
			webbläsare. Hur detta hänger ihop förklaras i detta kapitel.
		</para>
	</abstract>


	<sect1>
		<title>Webbläsaren</title>

		<para>
			Webbläsaren är den del av kedjan som är närmast användaren.
			Webbläsaren är det som du eller dina användare kommer i kontakt
			med. För att webbläsaren skall visa vettiga saker för användaren
			gäller att den matas med vettiga saker från ditt program.
		</para>

		<para>
			Webbläsaren förstår HTML
			<footnote>
				<para>
					Moderna webbläsare förstår en massa annat också, men det
					som är relevant i denna kurs är HTML
				</para>
			</footnote>
			så det som skall komma till webbläsaren är HTML. Webbläsaren förstår
			inte PHP-kod så PHP-koden måste tolkas av en PHP-tolk på webbservern.
		</para>
	</sect1>

	<sect1>
		<title>Webbservern</title>

		<para>
			Webbservern har till uppgift att serva webbläsaren med webbsidor.
			Kör man PHP så är det även på webbservern som PHP-koden tolkas.
			PHP-tolken gör inget för att det som kommer ut ur PHP-koden skall
			bli giltig HTML utan det är upp till dig som programmerare att se
			till att den är det.
		</para>

		<para>
			Webbservern har ofta en mängd olika funktioner beroende på vad den
			för tillfället skall göra. Du kan till exempel ha rena HTML-sidor
			parallellt med din PHP-filer. Webbservern vet vilka sidor som är
			PHP och vilka som är HTML och hanterar dem därefter.
		</para>
	</sect1>

	<sect1>
		<title>Program</title>
		<para>
			Programmet, eller skriptet, skall fungera så att det skriver ut
			HTML-kod som webbservern kan skicka till användarens webbläsare.
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Variabler</title>

	<abstract>
		<para>
			Detta avsnitt beskriver vad variabler är och hur man använder dem i
			ett PHP-script. Det tar även upp skillnaden mellan variabler i PHP
			och i andra vanliga kompilerande språk.
		</para>
	</abstract>

	<sect1>
		<title>Vad är en variabel</title>
		<para>
			En variabel är en platshållare för ett värde som ändras under
			programmets gång. Motsatsen till variabel är en konstant. En
			konstant kan eller får inte ändras under programmets gång.
		</para>

		<para>
			Ett exempel på en variabel kan vara termer i en addition. Tänk dig
			att du vill göra ett program som skall ränka ut en summa. Man skulle
			kunna göra programmet med bara konstanter, det skulle se ut så här:
			<example>
				<title>Exempel med variabler</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Addition</title>
</head>
<body>
   <?php
      echo "Summan av talen 1 och 2 är: ", 1 + 2;
   ?>
</body>
</html>
]]>
				</programlisting>
			</example>
			Som du kan se så räknar PHP ut vad 1 + 2 blir. Men vad har man för
			nytta av ett program som bara räknar ut 1 + 2. Vi vill ju kunna
			mata in vilka värden som helst för termerna.
		</para>

		<para>
			Se nedanstående exempel:
			<example>
				<title>Exempel med variabler</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Addition</title></head>
<body>
   <?php
      echo "Summan av talen 1 och 2 är: ", $_GET['tal1'] + $_GET['tal2'];
   ?>
</body>
</html>
]]>
				</programlisting>
			</example>
			Om du provar att köra programmet så kommer du nog att se att
			resultatet blir lite torftigt. Vi måste på något sätt ge variablerna
			$tal1 och $tal2 några väden. Prova att anropa programmet med
			http://dinserver/programnamnet.php?tal1=100&amp;tal2=199.
			Testa sedan andra ta och se vad som händer.
		</para>

		<para>
			Du kanske provade att sätta ett av talen till någor annat än ett
			tal, till exempel bosktäver?
			I så fall såg du att PHP inte kan summera text. Observera att om du
			matar in ett decimaltal så måste decimalpunkt och inte komma
			användas.
		</para>
	</sect1>


	<sect1>
		<title>Datatyper</title>
		<para>
			Alla programmeringsspråk arbetar med olika datatyper. I PHP behöver
			du inte ange vilken typ det är du jobbar med utan det listar
			programtolken ut från innehållet. Det är dock väldigt viktigt att
			man håller reda på vilka typer ens variabler har eftersom det kan bli
			underliga fel annars.
		</para>

		<para>
			Följande typer finns:
		</para>

		<sect2>
			<title>Skalära</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>boolean, bool (true, false)</para>
					</listitem>
					<listitem>
						<para>integer, int (heltal)</para>
					</listitem>
					<listitem>
						<para>float, double, real (reella tal)</para>
					</listitem>
					<listitem>
						<para>string (Textsträngar)</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Sammansatta</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>
							arrayer (En samling av värden som indexeras antingen av
							en integer eller string).
						</para>
					</listitem>
					<listitem>
						<para>
							objekt (Kommer inte att ingå i denna kurs, se manualen om
							du är intresserad).
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>

		<sect2>
			<title>Övriga speciella</title>
			<para>
				<itemizedlist>
					<listitem>
						<para>NULL (Variabeln har inget värde alls).</para>
					</listitem>
					<listitem>
						<para>
							resource (Innehåller en referense till en extern
							tillgång).
						</para>
					</listitem>
				</itemizedlist>
			</para>
		</sect2>
	</sect1>

	<sect1>
		<title>Övningar</title>

			<sect2>
				<title>Addition</title>
				<para>
					Skapa ett program som med hjälp av variabler summerar tre tal.
				</para>
			</sect2>
	</sect1>
</chapter>

<chapter>
	<title>Operander</title>

	<abstract>
		<para>
			Detta avsnitt beskriver vad operatorer är och hur man använder dem i
			ett PHP-script.
		</para>
	</abstract>

	<sect1>
		<title>Vad är en operator?</title>

		<para>
			En operator är något som verkar på en eller flera termer. Exempel på
			operatorer är +, -, * och / som gör precis vad ni tror att de gör.
		</para>
		<para>
			Det finns olika typer av operatorer. Aritmetiska operatorer, som de
			ovan, opererar bara på tal. Sedan finns det tilldelningsoperatorer
			som gör tilldelningar och så vidare. Här kommer några av de vi kommer
			att jobba med:
		</para>

		<sect2>
			<title>Aritmetiska operatorer</title>

			<para>
				<table frame='all'>
					<title>Aritmetiska operatorer</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>
						<thead>
							<row>
								<entry>Exempel</entry>
								<entry>Namn</entry>
								<entry>Resultat</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>$a + $b</entry>
								<entry>Addition</entry>
								<entry>Summan av $a och $b</entry>
							</row>
							<row>
								<entry>$a - $b</entry>
								<entry>Subtraktion</entry>
								<entry>Differensen av $a och $b</entry>
							</row>
							<row>
								<entry>$a * $b</entry>
								<entry>Multiplikation</entry>
								<entry>Produkten av $a och $b</entry>
							</row>
							<row>
								<entry>$a / $b</entry>
								<entry>Division</entry>
								<entry>Kvoten av $a och $b</entry>
							</row>
							<row>
								<entry>$a % $b</entry>
								<entry>Modulus</entry>
								<entry>Resten av division mellan $a och $b</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</sect2>

		<sect2>
			<title>Tilldelningsoperatorer</title>

			<para>
				Det finns bara en tilldelningsoperator och den heter helt enkelt
				"tilldelas". Den representeras av ett lika-med-tecken (=). Så här
				kan den användas:
				<example>
					<title>Tilldelningsoperatorn</title>
					<programlisting>
<![CDATA[
<?php
$c = $a + $b; //Utläses, c tilldelas a + b
?>
]]>
					</programlisting>
				</example>
			</para>
			<para>
				Det finns vissa andra tilldelningsoperatorer, men dessa behöver
				ni inte kunna. De är mest genvägar för de som är lata. Jag tar
				dem kort här.
				<!--
				XXX: Det är *INTE* för de som är LATA! Det blir snyggare och
				     enklare kod och mindre att underhålla =)
				-->
				<example>
					<title>Tilldelningsoperatorerna += och -=</title>
					<programlisting>
<![CDATA[
<?php
$a += 5 // Samma sak som $a = $a + 5
$a -= 5 // Samma sak som $a = $a - 5
?>
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>Jämförelseoperatorer</title>
			<para>
				Jämförelseoperatorer arbetar på tal och returnerar alltid ett
				värde av typen boolean. Det vill säga true eller false.

				<table frame='all'>
					<title>Jämförelseoperatorer</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>

						<thead>
							<row>
								<entry>Exempel</entry>
								<entry>Namn</entry>
								<entry>Resultat</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>$a == $b</entry>
								<entry>Lika med</entry>
								<entry>Sant om $a är lika med $b</entry>
							</row>
							<row>
								<entry>$a != $b</entry>
								<entry>Inte lika med</entry>
								<entry>Sant om $a inte är lika med $b </entry>
							</row>
							<row>
								<entry>$a &lt; $b</entry>
								<entry>Mindre än</entry>
								<entry>Sant om  $a är mindre än $b </entry>
							</row>
							<row>
								<entry>$a &gt; $b</entry>
								<entry>Större än</entry>
								<entry>Sant om  $a är större än $b</entry>
							</row>
							<row>
								<entry>$a &lt;= $b</entry>
								<entry>Mindre än eller lika med</entry>
								<entry>
									Sant om $a är mindre än eller lika med $b
								</entry>
							</row>
							<row>
								<entry>$a &gt;= $b</entry>
								<entry>Större än eller lika med</entry>
								<entry>
									Sant om $a är större än eller lika med $b
								</entry>
							</row>
							<row>
								<entry>$a === $b</entry>
								<entry>Identiska</entry>
								<entry>
									Sant om $a är lika med $b och båda är av samma typ
								</entry>
							</row>
							<row>
								<entry>$a !== $b</entry>
								<entry>Inte identiska</entry>
								<entry>
									Sant om $a inte är lika med $b eller att de inte
									är av samma typ.
								</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</sect2>

		<sect2>
			<title>Logiska operatorer</title>

			<para>
				Som jag sade ovan så returnerar alltid de jämförande operatorerna
				av typen boolean och opererar på tal. Logiska operatorer
				returnerar alltid boolean, men opererar också bara på logiska
				termer.

				<table frame='all'>
					<title>Logiska operatorer</title>
					<tgroup cols='3' align='left' colsep='1' rowsep='1'>
						<colspec colname='c1'/>
						<colspec colname='c2'/>
						<colspec colname='c3'/>

						<thead>
							<row>
								<entry>Exempel</entry>
								<entry>Namn</entry>
								<entry>Resultat</entry>
							</row>
						</thead>
						<tbody>
							<row>
								<entry>$a and $b</entry>
								<entry>Och</entry>
								<entry>Sant om $a och $b är sanna</entry>
							</row>
							<row>
								<entry>$a or $b</entry>
								<entry>Eller</entry>
								<entry>Sant om $a eller $b är sanna</entry>
							</row>
							<row>
								<entry>$a xor $b</entry>
								<entry>Exklusivt eller</entry>
								<entry>
									Sant om $a eller $b är sanna men inte båda två
								</entry>
							</row>
							<row>
								<entry>!$a</entry>
								<entry>Inte/Icke</entry>
								<entry>Sant om $a inte är sant</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</para>
		</sect2>

		<sect2>
			<title>Strängoperatorer</title>
			<para>
				Det finns tre operatorer som opererar på strängar, den första
				känner ni till sedan förut och det är tilldelningsoperatorn
				"tilldelas". Den fungerar lika på strängar som på tal. Sedan
				finns det två till. Dessa beskrivs lättast med ett exempel:

				<example>
					<title>Strängoperatorer</title>
					<programlisting>
<![CDATA[
<?php
$s = "Kalle ";    //$a tilldelas "Kalle "
$t = $a . "Anka"; //$t innehåller nu "Kalle Anka"
$s = "Kalle ";
$s .= "Anka";     //Samma sak som $s = $s . "Anka"
?>
]]>
					</programlisting>
				</example>
			</para>
		</sect2>
	</sect1>

	<sect1><title>Mer läsning</title>
		<para>
			Det står mycket om operatorer i PHP-Manualen (
			<ulink url="http://www.php.net/manual/en/language.operators.php">
				<citetitle>
					http://www.php.net/manual/en/language.operators.php
				</citetitle>
			</ulink>).
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Selektioner (Villkorssatser)</title>

	<abstract>
		<para>
			I de allra flesta programmeringsspråk finns det selektionssatster.
			Precis som namnet antyder handlar det om val. Programmet kan ta
			olika vägar beroende på olika villkor. Vanliga selektionssatser
			är if-satsen och if-else-satsen.
		</para>
	</abstract>

	<sect1>
		<title>If-satsen</title>
		<para>
			If-satser finns i de allra flesta språk och ser nästan likadan ut
			i dem alla. If-satsen fungerar som så att om något är sant så gör
			en sak, annars inte. Ett exempel är på sin plats.
		</para>

		<para>
			Antag att jag vill att ett program skall tala om för mig om ett
			tal är större än 100. Jag vill att programmet skall skriva ut det
			tal jag anger och om det är större än 100 så skall det också
			skrivas ut. Så här kan det se ut:
			<example>
				<title>Större än 100</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Större än 100</title>
</head>
<body>
   <?php
      echo "Du angav tal: $tal";

      if ($tal > 100) {
         echo "<p><emphasis>$tal är större än 100</emphasis></p>";
      }
   ?>
</body>
</html>
]]>
				</programlisting>
			</example>

			If-satsen består alltså av ordet if följt av ett test inom
			parenteser. Satsen som följer efter utförs om testet blir sant.
			Vill man att det skall vara flera satser som utförs om testet blir
			sant kan man slå ihop dem till ett block med hjälp av { och }
			(måsvingar). I exemplet ovan använder jag måsvingarna fast de
			egentligen inte behövs. Som regel är det bäst att alltid sätte dit
			måsvingarna ifall man vill stoppa in en rad till inom if-satsen
			sedan så glömmer man dem inte.
		</para>
		<para>
			Studera nu if-satsen ovan och skriv om programmet och testa olika
			tal.
		</para>
	</sect1>

	<sect1>
		<title>If-else-satsen</title>

		<para>
			Nu fungerar programmet så långt. Men det vore ju kul om programmet
			sade till även om talet inte är större än 100. Alltså om det är
			större än 100 skriv det annars skriv att det inte är större än 100.
		</para>

		<para>
			Studera följande exempel
			<example>
				<title>If-else exempel</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Större än 100</title>
</head>
<body>
<?php
echo "Du angav tal: $tal";

if ($tal > 100) {
   echo "<p><emphasis>$tal är större än 100</emphasis></p>";
} else {
   echo "<p><emphasis>$tal är inte större än 100</emphasis></p>";
}
?>
</body>
</html>
]]>
				</programlisting>
			</example>

			I exemplet ovan ser vi hur en if-else sats fungerar. Om uttrycket
			inom parenteserna är sant utförs det som kommer efter. Om inte så
			utförs det som kommer efter else. <emphasis> Det kan aldrig inträffa
			att båda satserna utförs!</emphasis>
		</para>
	</sect1>

	<sect1>
		<title>if-elseif</title>

		<para>
			If-elseif är också en valig kunstruktion. Den används ofta till
			sammans med else och blir då en if-elseif-else sats. Man kan ha
			flera elseif i en konstruktion men bara en else. Det som kommer
			efter det första sanna uttrycket utförs och inget annat. Om inget
			är sant kommer det som står efter else (annars) att utföras.
		</para>

		<para>
			Vi tittar på vårt exempel igen. Talet man anger kan ju vara större
			eller mindre än 100. Är det inte det så måste det ju vara talet 100
			som angets. Vi testar igen.

			<example>
				<title>if-elseif-else</title>
				<programlisting>
<![CDATA[
<html>
<head>
   <title>Större än 100</title>
</head>
<body>
<?php
echo "Du angav tal: $tal";

if ($tal > 100) {
   echo "<p><emphasis>$tal är större än 100</emphasis></p>";
} elseif ($tal < 100) {
   echo "<p><emphasis>$tal är inte större än 100</emphasis></p>";
} else {
   echo "<p><emphasis>$tal är ju lika med 100</emphasis></p>";
}
?>

</body>
</html>
]]>
				</programlisting>
			</example>

			Som vi ser så är den inte helt olik de anda konstruktionerna med if.
			Den fungerar så att om det första testet är sant så utförs satsen
			efter det. Om inte görs testen efter elseif. Är denna sann så utförs
			satsen efter den. Om inget test har varit sant utförs det som kommer
			efter else. Det kan vara flera elseif och else kan utelämnas.

		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Aktuellt avsnitt i PHP-manualen.
			<ulink url="http://www.php.net/manual/en/control-structures.php">
				<citetitle>
					http://www.php.net/manual/en/control-structures.php
				</citetitle>
			</ulink>
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Iterationer (Upprepningar, loopar)</title>

	<abstract>
		<para>
			Datorprogram är extremt bra på att göra saker om och om igen, utan
			att ledsna eller göra fel. Till detta använder man någon typ av
			iterationssats (iteration = upprepning).
		</para>
	</abstract>

	<sect1>
		<title>While-satsen</title>

		<para>
			While-satsen är en vanlig iterationssats. Den fungerar så att en
			sats (som kan vara ett block) körs om och om igen så länge som ett
			test är sant. Studera följande exempel som skriver ut tiotusen
			ettor.

			<example>
				<title>Exempel med while</title>
				<programlisting>
<![CDATA[
<?php
// Exempel på while-loop

echo "<h1>Tiotusen ettor</h1>";

$a = 0;
while ($a < 10000) {
	echo "1 ";
   $a++;
}
?>
]]>

				</programlisting>
			</example>

			Vi tittar på exemplet rad för rad. Raden som börjar med "//" är en
			kommentar, den kan ni ignorera, kommentarer är viktiga men vi kommer
			att gå igenom dem lite senare.
		</para>

		<para>
			Den andra raden är starten på while-loopen (kallas även loop eftersom
			den loopar om och om igen). Så länge som testet ($a &lt; 10000) är
			sant so kommer satsen efter att repeteras. När $a är större ön eller
			lika med 10000 kommer loopen att avbryts. Om man i loopen glömmer att
			öka $a kommer testet alltid att vara sant och man kommer aldrig ur
			loopen.  Detta kallas för en oändlig loop och är ett vanligt
			programmeringsfel som gör att programmet hänger sig!
		</para>

		<para>
			Om testet inte är sant från början så kommer aldrig det står i satsen
			att köras. Se därför till att testet är sant från början.
		</para>
	</sect1>

	<sect1>
		<title>do-while-satsen</title>

		<para>
			Do-while liknar på många sätt den vanliga while-satsen. Den enda
			skillnaden är att det som står i satsen alltid kommer att utföras
			åtminstone en gång. Se följande exempel:

			<example>
				<title>Exempel med do-while</title>
				<programlisting>
<![CDATA[
<?php
// Ett exempel på hur man använder do-while

$i = 0;

do {
   echo "$i ";
   $i++;
} while ($i < 100);

?>
]]>

				</programlisting>
			</example>

			Tilldelningen till $i är viktig eftersom den sätter värdet där
			loopen skall börja. I loopen 	skrivs först $i ut och sedan ökas
			variabeln $i med ett. Detta sker så länge som $i är mindre än 100.
			Alltså från 0 till 99.
		</para>
	</sect1>

	<sect1>
		<title>for-loopen</title>

		<para>
			For är den vanligaste iterationen. Den är dock vid en första anblick
			lite krångligare än de andra. Man kan om man vill använda while
			istället för for om man vill, men när man kan for är den mycket
			smidigare.
		</para>

		<para>
			for-loopen skriver man med det reserverade ordet for följt av en
			parentes. Inom parentesen skall det stå tre stycken uttryck. Dessa
			tre skall se ut enligt följande.

			<itemizedlist>
				<listitem>
					<para>
						Det första kommer att exekveras en gång inan loopen börjar.
					</para>
				</listitem>
				<listitem>
					<para>
						Det andra skall vara ett boolskt uttryck. Loopen kommer att
						gå så länge detta är sant.
					</para>
				</listitem>
				<listitem>
					<para>
						Det tredje körs efter varje gång som loopen har gått.
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
			Nu känner jag att exempel är på sin plats igen:

			<example>
				<title>Exempel med for-loop</title>
				<programlisting>
<![CDATA[
<?php
//Exempel på for-loop

for ($i = 0; $i <= 10; $i = $i++) {
   echo "$i<br>\n";
}
?>
]]>

				</programlisting>
			</example>

			Oftast används de tre olika satserna på precis det sätt som visas
			ovan. Nämligen att initiera en räknare, kolla ett gränsvärde och
			räkna upp räknaren, men inget hindrar att man använder dem på andra
			sätt.
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Aktuellt avsnitt i PHP-manualen:
			<ulink url="http://www.php.net/manual/en/control-structures.php">
				<citetitle>
					http://www.php.net/manual/en/control-structures.php
				</citetitle>
			</ulink>
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Mer om strängar</title>

	<abstract>
		<para>
			Strängar är en typ som består av följder av tecken. Till exempel så
			är "Jag heter Marcus" en sträng. I detta avsnitt tittar vi lite mer
			på vad man kan göra med strängar.
		</para>
	</abstract>

	<sect1>
		<title>Vad är en sträng</title>

		<para>
			En sträng är en grupp av tecken. Strängar förekommer, i stort sett,
			i alla program. PHP är ett språk som är väldigt rikt på funktioner
			för att hantera strängar. Mycket beroende på att det är ett språk
			för web-programmering där i princip allt som kommer från programmet
			är strängar. Det uppmuntrar även till att man låter okända användare
			mata in strängar till programmen vilket gör att man av säkerhetsskäl
			måste vara försiktig med strängarna.
		</para>

		<para>
			I PHP markeras en sträng av att den innesluts av enkla eller dubbla
			fnuttar (citationstecken). Skillnaden är den att inom dubbla fnuttar
			(vanliga citationstecken) kommer alla variabler i strängen att bytas
			ut mot sitt värde. Se följande lilla exempel:

			<example>
				<title>Exempel med strängar</title>
				<programlisting>
<![CDATA[
<?php
$summa = 1 + 6;
echo "Summan är $summa"; // Skriver ut: Summan är 7
echo 'Summan är $summa'; // Skriver ut: Summan är $summa
?>
]]>
				</programlisting>
			</example>

			Som du ser så sker ingen variabelsubstitution i den andra raden
			eftersom den omges av enkla fnuttar.
		</para>
	</sect1>

	<sect1>
		<title>Escape-tecken</title>

		<para>
			Som vi såg i förra stycket så omges en sträng av fnuttar. En naturlig
			fråga man då ställer sig är vad som händer om jag vill ha fnuttar i
			en sträng. Se följande exempel:

			<example>
				<title>Citationstecken i strängar</title>
				<programlisting>
<![CDATA[
<?php
echo "Tjenare din gamle "hacker"";
?>
]]>
				</programlisting>
			</example>

			Man ser direkt att det inte kommer att bli bra. Hur skall tolkaren
			kunna veta var strängen slutar? Det som kommer att ske är att
			strängen börjar vid den första fnutten och slutar vid den andra.
			Den bosktav (h) som kommer efter kommer att orsaka ett "pars error".
			Hur gör man då?
			Jo om man vill infoga specialtecken i en sträng måste dessa föregås
			av specialtecknet \ (bakvänt snedstreck eller backslash). Strängen
			ovan blir då:

			<example>
				<title>Exempel på escape-tecken</title>
				<programlisting>
<![CDATA[
<?php
echo "Tjenare din gamle \"hacker\"";
?>
]]>
				</programlisting>
			</example>

			Nu blir utskrifter som vi tänkt oss. Det finns även andra
			specialtecken:

			<table frame='all'>
				<title>Specialtecken i strängar</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>

					<thead>
						<row>
							<entry>Teckenkombination</entry>
							<entry>Skrivs ut som</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>\"</entry>
							<entry>"</entry>
						</row>
						<row>
							<entry>\'</entry>
							<entry>'</entry>
						</row>
						<row>
							<entry>\\</entry>
							<entry>\</entry>
						</row>
						<row>
							<entry>\$</entry>
							<entry>$</entry>
						</row>
						<row>
							<entry>\n</entry>
							<entry>Ny rad</entry>
						</row>
						<row>
							<entry>\t</entry>
							<entry>Tab</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			I strängar inom enkelfnuttar (') så substitueras bara "\'".
			Alla andra representerar sig själva.
		</para>
	</sect1>

	<sect1>
		<title>Lägga ihop strängar</title>

		<para>
			Man kan inte lägga ihop strängar med hjälp av additionsoperatorn
			(+).  Den är ju till för aritmetiska termer. Som tur är så finns
			det speciella opteratorer för just strängar. Den som lägger ihop
			två strängar kallas för concatenationsoperatorn. Den representeras
			av tecknet "." (punkt).  Se nedanstående exempel.

			<example>
				<title>Exempel med strängar</title>
				<programlisting>
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // Vi lägger till strängen "World!" efter $a
echo $b; // Skriver ut "Hello World!"
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Jämföra strängar</title>

		<para>
			I PHP kan man jämföra strängar med de operaorer som vi lärt oss för
			numeriska värden. Det är ganska specifikt för PHP. Räkna inte med
			att du kan göra så i andra språk du kommer i kontakt med. Även i PHP
			finns det funktioner för att jämföra strängar.
		</para>

		<sect2>
			<title>Strcmp och strcasecmp</title>

			<para>
				Strcmp (STRing CoMPare) är en funktion som jämför två strängar
				med varandra. Om de är exakt likadana returneras värdet 0. Om
				den första är större returneras 1 och om den andra är större
				returneras -1. Syntaxen och ett exempel på hur den kan användas
				visas i nedanstående exempel.

				<example>
					<title>Exempel med strcmp</title>
					<programlisting>
<![CDATA[
<?php
if (strcmp($password, "Hemligt") == 0) {
   echo "Rätt lösenord";
} else {
   echo "Fel lösenord!";
}
?>
]]>
					</programlisting>
				</example>

				Tänk på att strcmp gör skillnad på stora och små bokstävar.
				Texten "Rätt lösenord" ovan kommer bara att skrivas ut om
				$password innehåller exakt "Hemligt". Vill du jämföra
				strängen utan att versaler/gemener skall ha någon betydelse
				kan du prova strcasecmp som fungerar på samma sätt fast
				"case insensitive".
			</para>
		</sect2>
	</sect1>

	<sect1>
		<title>Ändra strängar</title>

		<para>
			Ofta vill man ändra på strängar så att de ser lite annorlunda ut.
			Det kan vara att man vill göra om alla bokstäver till versaler
			eller gemener. Eller att man vill byta något ord mot ett annat.
			PHP har massor av funktioner för detta. Vanliga saker man vill
			göra med strängar är att byta ut en förekomst av ett ord mot ett
			annat eller att göra alla tecken till små eller stora bosktäver
			eller ta bort tomma tecken.
		</para>

		<sect2>
			<title>strtoupper och strtolower</title>

			<para>
				Dessa två funktioner (STRing TO UPPERcase och LOWERcase) tar
				en sträng som argument och returnerar samma sträng med alla
				bokstäver konverterade till antingen stora bokstäver (versaler)
				eller små bokstäver (gemener).
			</para>

			<para>
				Se följande lilla exempel:

				<example>
					<title>Exempel med strtoupper och strtolower</title>
					<programlisting>
<![CDATA[
<?php
$str1 = "Kalle Anka";
$str2 = strtolower($str1);  // str2 blir "kalle anka"
$str3 = strtoupper($str1);  // str3 blir "KALLE ANKA"
echo "\$str1: ". $str1;
echo "\n\$str2: ". $str2;
echo "\n\$str3: ". $str3 ."\n";
?>
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>Ucfirst och ucwords</title>

			<para>
				Dessa två funtioner (UpperCase FIRST och WORDS) är kanske inte
				lika användbara som strtoupper och strtolower men kan vara bra
				att känna till. De kan användas till exempel om man vill snygga
				till användarinmatad data. Vad de gör är att göra den första
				bokstaven i en sträng (ucfirst) eller första bokstaven i varje
				ord i strängen (ucwords) till gemen. Observera att dessa
				funktioner bara verkar på de tecken det gäller och inte de
				övriga. Se följande exempel:

				<example>
					<title>Exempel med ucfirst och  ucword</title>
					<programlisting>
<![CDATA[
<?php
$str1 = "kalle anka";
$str2 = ucwords($str1); // str2 blir "Kalle Anka"

$str1 = 'KALLE ANKA';
$str2 = ucwords($str1); // str2 blir KALLE ANKA (inga tecken blir gemener)

$str3 = ucwords(strtolower($str1)); // str3 blir Kalle Anka
?>
]]>
					</programlisting>
				</example>

				I exemplet ser vi att "KALLE ANKA" blir samma sak efter ucwords.
				Det beror på att denna funktion bara verkar på det första
				tecknet i varje ord. Detta görs versalt. Inget annat görs. Är
				alla tecken versaler så kommer inget att ske. I den sista satsen
				lägger vi in ett anrop till strtolower vilket gör att ucwords
				matas med strängen "kalle anka" istället.
			</para>

			<para>
				Ucfirst fungerar på exakt samma sätt fast bara på det allra
				första tecknet i strängen.
			</para>
		</sect2>

		<sect2>
			<title>strrev</title>

			<para>

				Detta är en väldigt trevlig lite funktion (STRing REVerse). Det
				enda den gör är att den tar en sträng som argument och returnerar
				samma sträng fast reverserad.

				<example>
					<title>Exempel med strrev</title>
					<programlisting>
<![CDATA[
<?php
$str1 = "Kalle Anka";
$str2 = strrev($str1); // str2 blir "aknA ellaK"
?>
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>strlen</title>

			<para>
				En betydligt mer användbar funktion än strrev är strlen (STRing
				LENgth). Denna returnerar antalet tecken i en sträng.
			</para>

			<para>
				Som vanligt tar vi ett litet exempel:

				<example>
					<title>Exemepel med strrev</title>
					<programlisting>
<![CDATA[
<?php
$str1 = "Kalle Anka";
echo strlen($str1);          // skriver ut 10
echo strlen(" Kalle Anka "); // skriver ut 12
?>
]]>
					</programlisting>
				</example>
			</para>
		</sect2>

		<sect2>
			<title>str_replace</title>

			<para>
				Detta är en mycket användbar funktion. Den byter ut en teckenföljd
				i en mening mot en annan. Funktionen tar tre argument och
				returnerar en sträng. Det första argumentet är den teckenföljd som
				skall ersättas, det andra är det som det skall ersättas med och
				det tredje argumentet är den sträng som det hela berör. Det som
				returneras är strängen i det tredje argumentet där alla
				förekomster av teckenföljden i det första argumentet ersatts med
				tecknen i det andra argumentet.
			</para>

			<para>
				Förvirrad? Se nedanstående exempel:

				<example>
					<title>Exempel med str_replace</title>
					<programlisting>
<![CDATA[
<?php
$str1 = "Kalle Anka är bäst";
$str2 = str_replace("Kalle", "Kajsa", $str1);

echo $str2;  // str2 är "Kajsa Anka är bäst"
?>
]]>
					</programlisting>
				</example>

				Detta är användbart till väldigt mycket. Bara fantasin sätter
				gränserna.
			</para>
		</sect2>
	</sect1>

	<sect1>
		<title>Hantera oönskad HTML i strängar</title>

		<para>
			I PHP hanterar man av naturliga själ ofta strängar som skall
			presenteras i en webläsare. Flera av dessa strängar kommer vanligtvis
			från användare eller andra osäkra källor. Då vill man gärna
			kontrollera så att inte användaren kan mata in data som förstör
			resten av sidan. Till exempel så skall man inte i ett web-forum kunna
			skriva in HTML-kod hur som helst.  Man skulle då kunna länka in fula
			bilder eller andra typsnittet på hela sidan. Man kan åstadkomma detta
			genom att använda massor av anrop på str_replace. Till exempel:

			<example>
				<title>Men str_replace</title>
				<programlisting>
<![CDATA[
<?php
//
// Följande två rader tar bort alla förekomster av större än och
// mindre än och ersätter dem med deras HTML-motsvarighet. Detta
// eliminerar alla HTML-taggar.
//
$html_string = str_replace("&lt;", "&amp;lt;", $html_string);
$html_string = str_replace("&gt;", "&amp;gt;", $html_string);
?>
]]>
				</programlisting>
			</example>

			Men det finns bättre sätt att göra det på. Det finns (naturligtvis)
			färdiga funktioner som gör HTML av strängar, till exempel
			htmlentities. htmlentities gör om en sträng så att alla tecken som har
			en motsvarighet i HTML kod blir just, HTML kod.
			Funktionen tar ett argument och har två stycken valfria argument som
			du inte behöver ange, mer än om du t.ex. behöver använda en annan
			teckensnittsuppsättning. Se följande exempel:

			<example>
				<title>Exempel med htmlentities</title>
				<programlisting>
<![CDATA[
<?php
$str1 = "<h1>Kalle Anka</h1>"; // Blir "Kalle Anka" (Rubrik 1) i browsern
$str2 = htmlentities($str1);   // Blir <h1>Kalle Anka</h1>; i browsern
?>
]]>
				</programlisting>
			</example>

			Detta gör att allt man skickar till htmlentities kommer att synas i
			browsern precis som det ser ut i klartext.
		</para>
	</sect1>

	<sect1>
		<title>Söka i strängar</title>

		<para>
			Ofta vill man hitta eller använda bara vissa delar av en sträng. Det
			finns flera funktioner för detta. Vi skall titta på två av dem.
		</para>

		<sect2>
			<title>strstr och stristr</title>

			<para>
				Dessa två funktioner fungerar så att de tar två argument, båda är
				strängar (STRing in STRing och STRing case-Insensitive in STRing).
				Den första är den sträng som det skall sökas i och det andra är
				det sökta.  Det som returneras är det som är kvar av det första
				argumentet efter den funna strängen. Förvirrad?

				<example>
					<title>Exemempel med strstr()</title>
					<programlisting>
<![CDATA[
<?php
$namn = "Kalle Anka";
$enamn = strstr($namn, " ");    // enamn blir " Anka"

$adress = "kalle@ankeborg.net";
$domain = strstr($adress, "@"); // domain blir "@ankeborg.net"
?>
]]>
					</programlisting>
				</example>

				Funktionen stristr fungerar på samma sätt men den bryr sig inte
				om om den eftersökta strängen har stora eller små bokstäver
				(Case-Insensitive).

			</para>
		</sect2>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Aktuellt avsnitt i Manualen.
			<ulink url="http://www.php.net/manual/en/ref.strings.php">
				<citetitle>
					http://www.php.net/manual/en/ref.strings.php
				</citetitle>
			</ulink>
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Pseudokod</title>

	<abstract>
		<para>
			Kommer ...
		</para>
	</abstract>


	<sect1>
		<title>Mer läsning</title>

		<para>
			Länkar till mera läsning för den intresserade
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Indentering</title>

	<abstract>
		<para>
			Att indentera sin kod är något man gör för att den skall bli lättare
			att läsa och lättare att hitta fel. Detta avsnitt beskriver hur man
			indenterar på ett bra sätt.
		</para>
	</abstract>

	<sect1>
		<title>Vad är indentering?</title>

		<para>
			Indentering går ut på att man med hjälp av olika mycket blanksteg
			(space) till vänster om koden kan på ett logiskt sätt gruppera koden
			så att den går lättare att läsa. Det finns flera olika sätt att
			intendera på och varje programmerare har sin egen stil. För att kod
			skall bli enhetliga så har många företag en kodstandard i vilken det
			beskrivs hur kommentering och indentering skall göra inom företaget.
			Det gör att alla programmerare känner sig hemma i varandras kod och
			att den totala kodmassan blir enhetlig och lättare att granska.
		</para>

		<para>
			Grundprincipen är att kod som hänger ihop skall ha samma
			indenteringsnivå. Se följande exemepel:

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
if ($tal = 100) {
   echo "Talet är 100";
   $tal = $tal + 1;
}
?>
]]>
				</programlisting>
			</example>

			I exemplet ser vi att det som hör till if-satsen har flyttats in en
			nivå. Det gör det lätt att se att det hör till if-satsen och att
			måsvingarna är riktiga. Vissa indenterar if-satsen så här:

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
if ($tal = 100)
{
   echo "Talet är 100";
   $tal = $tal + 1;
}
?>
]]>
				</programlisting>
			</example>

			Om vi säger att vi har nästlade if-satser så syns det ännu tydligare
			vad bra det är att indentera.

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
if ($inloggad) {
   if ($tal = 100) {
      echo "Tal är hundra";
   } else {
      echo "Tal är inte hundra";
   }
} else {
   echo "Du är inte inloggad!"
}
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Länkar till mera läsning för den intresserade
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Kommentering</title>

		<abstract>
			<para>
				Alla som någon gång jobbat i ett programmeringsprojekt vet att det
				är av yttersta vikt att man kommenterar sin kod. Detta avsnitt
				beskriver hur man kommenterar och vad man skall tänka på när man
				kommenterar sin kod.
			</para>
		</abstract>

		<sect1>
			<title>Hur ser en kommentar ut</title>

			<para>
				I PHP finns det två typer av kommentarer. De är <emphasis>//
				Kommentar</emphasis> och <emphasis>/* Kommentar */</emphasis>.
				Den första fungerar så att allt som kommer efter <emphasis>//
				</emphasis> och fram till radens slut är en kommentar och kommer
				att ignoreras av PHP-tolkaren. Den andra typen av kommentar
				fungerar så att det som står mellan <emphasis>/*</emphasis> och
				<emphasis>*/ </emphasis> är kommentarer. Den andra varianten kan
				sträcka sig över flera rader.

				<example>
					<title>Exempel med kommentering</title>
					<programlisting>
<![CDATA[
<?php
/* Detta är en kommentar*/
// Detta är en kommentar
$i = 1000; // Detta är också en kommetar
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Att kommentera sin kod</title>

		<para>
			Att kommentera i sin kod är en konst. Det är mycket att tänka på. Det
			som är svårast är att veta hur mycket man skall kommentera. Det är
			lika illa att kommentera för mycket som för lite. Här kommer några
			riktlinjer.
		</para>

		<para>
			Skriv i kommentaren VAD som görs och inte HUR det görs. Hur det görs
			skall koden i sig själv förklara.
		</para>

		<para>
			Kommentera i en sammanhängande längre kommentar före ett avancerat
			block vad som görs. Ett litet exempel:

			<example>
				<title>Längre kommentar före block</title>
				<programlisting>
<![CDATA[
<?php
//
// Nedanstående räknar ut summan av alla tal mellan tal1 och
// tal2.
//
// Summan skrivs ut och tal2 måste vara större än tal1
//

$summa = 0;
for ($i = $tal1; $i <= $tal2; $i++) {
   $summa = summa + i;
}
echo $summa;
?>
]]>
				</programlisting>
			</example>

			Jämför detta med nedanstående kod som är full av "Papegojkommentarer"
			(En papegoja brukar bara lära sig att upprepa det den hör).

			<example>
				<title>Papegojkommentarer</title>
				<programlisting>
<![CDATA[
<?php
$summa = 0; // Summan sätts till 0

for ($i = $tal1; $i <= $tal2; $i++) { // Räkna upp i från $tal1 till $tal2
   $summa = summa + $i; // Aktuellt tal läggs till summan
}
echo $summa; // Skriv ut summan
?>
]]>
				</programlisting>
			</example>

			Observera att det är svårare att förstå vad den här koden gör än den
			ovanför. Trots att den är full av kommantarer. Den nedre har bara
			kommentarer som beskriver vad koden i sig beskriver och tillför
			inget. Radkommentarer är tillåtet om de gör någon nytta. Till exempel
			då variabler deklareras är det bra att ha radkommentarer efter varja
			variabel där man beskriver vad man tänkt att variabeln skall göra.
		</para>
	</sect1>

	<sect1>
		<title>Liten sammanfattning</title>

		<para>
			<itemizedlist>
				<listitem>
					<para>Kommentera inte för mycket och inte för litet.</para>
				</listitem>
				<listitem>
					<para>Koden i sig skall visa vad programmet gör.</para>
				</listitem>
				<listitem>
					<para>
						Beskriv gärna i en (längre) kommantar före en funktion eller
						avancerat block i en funktion vad det gör istället för att
						kommantera på varje rad.
					</para>
				</listitem>
				<listitem>
					<para>
						Kommentarer på samma rad som koden blir lätt
						"Papegojkommentarer" sådana är fula och skall inte
						göras.
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
			Ett mer sammanhängande exempel finns nedan:

			<example>
				<title>Kommentering sammanhängade exempel</title>
				<programlisting>
<![CDATA[
<?php
//
// kommentering.php
//
// Detta är ett litet skript som bara demonstrerar kommentering.
// I början av varje fil är det väldigt bra om man har ett block
// som detta där det står vad som finns i filen. Och hur man får
// tag i programmeraren.
//
// Av: Marcus Rejås <marcus@rejas.se>
// Ver: 1.002
//

//
// Följande visar hur användarens browser presenterar sig. Det
// är bra att före avancerade block eller funktioner i koden
// beskriva vad koden gör.
//

echo "Din browser presenterar sig som:<br>";
echo $HTTP_USER_AGENT;


//
// Man kan även visa vilket IP de kommer från
//
echo "<p>Du har IP-nummer:<br>";
echo $REMOTE_ADDR;

//
// Skriver ut alla tal mellan 1 och 10
//
echo "<p>Alla tal mellan 1 och 10 ";
$tal = 1;
while ($tal <= 10) {
   echo "$tal ";
   $tal++;
}

// Nedan visas samma kod med "Papegojkommentarer"
echo "<p>Alla tal mellan 1 och 10 ";
$tal = 1;               // Tal tilldelas 1
while ($tal <= 10) {    // Så länge som tal <= 10
   echo "$tal ";       // Skriv ut tal
   $tal++;             // Öka tal med ett
}

// Vilket går lättast att förstå?

// Exempel på en block-kommentar. Nedanstående är helt
// bortkommenterat

/*
  Nedan visas samma kod med "Papegojkommentarer"
$tal = 1;               // Tal tilldelas 1
while ($tal <= 10) {    // Så länge som tal <= 10
   echo "$tal ";       // Skriv ut tal
   $tal++;             // Öka tal med ett
}
*/

//
// Märk att man kan nästla kommentarer av olika typ men inte av
// samma.
//

echo "<hr>Detta är bara ett skript som demonstrerar kommentering.
Titta på källkoden istället.";

?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Länkar till mera läsning för den intresserade
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Funktioner</title>

	<abstract>
		<para>
			Funktioner används för att dela upp programmet i mindre små delar.
			Det gör att programmeraren kan koncentrera sig på en del i taget
			och löper mindre risk att göra fel.
			<!--
			XXX: Mindre duplikerad kod vilket gör det lättare att debugga och
			     underhålla. Duplikation är EVOL!
			-->
		</para>
	</abstract>

	<sect1>
		<title>Vad är en funktion?</title>

		<para>
			En funktion är ett antal instruktioner som fristående utför en sak.
			Denna snutt kan sedan köras om och om i samma program eller delas
			med andra program.
			Ett exempel:
			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
/*
 * print_html_header_start
 *
 * Skriver ut en html-header
 */
function print_html_header_start () {
   echo "<html><head></head><body>";
}

/*
 * print_html_header_stop
 *
 * Skriver ut slut-html-taggar
 */
function print_html_header_stop () {
   echo "</body></html>";
}


// Här börjar programmet
print_html_header_start();

// Andra utskrifter här.
print_html_header_stop();
?>
]]>
				</programlisting>
			</example>

			I exemplet ovan deklareras två funktioner som skriver ut en
			html-header och en html-footer. Dessa funktioner anropas längre
			ned i programmet.
		</para>
	</sect1>

	<sect1>
		<title>När skall man använda funktioner?</title>

		<para>
			Man skall använda funktioner så snart man kan. Själva programmet
			brukar ofta vara bara anrop till olika funktioner. Följande kan vara
			bra grundregler.
		</para>

		<para>
			Använd funktioner till:

			<itemizedlist>
				<listitem>
					<para>
						Alla uppgifter som kan avgränsas
					</para>
				</listitem>
				<listitem>
					<para>
						Alla uppgifter som är repititiva
					</para>
				</listitem>
				<listitem>
					<para>
						All kod som du kan tänkas återanvända i andra program
					</para>
				</listitem>
			</itemizedlist>

			Försök att tänka ett program i funktioner.
		</para>

		<para>
			Vi funderar på programmet password.php och försöker identifiera
			olika funktioner.
		</para>

		<para>
			En funktion är att skriva ut html-formuläret. Det är ju en avgränsad
			uppgift. En annan solklar funktion är autentiseringen.
		</para>
	</sect1>

	<sect1>
		<title>Argument till funktioner</title>

		<para>
			En funktion kan ta noll eller flera argument. Ett argument är ett
			värde som man skickar till funktionen. Till exempel om man vill vill
			göra en funktion som summerar två tal så är det bra om den kan ta de
			två talen som argument. Se följande exempel:

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
funtion summa($tal1, $tal2) {
        return ($tal1 + $tal2);
}

echo summa(5,6);
?>
]]>
				</programlisting>
			</example>

			Observera att ordningen på argumenten spelar roll. I exemplet kommer
			tal1 att bli 5 och tal2 6. Variablerna $tal1 och $tal2 existerar
			bara inom funktionen och inte i resten av programmet. Vilken som får
			vilket värde bestäms av ordningen i funktionsanropet.
		</para>
	</sect1>

	<sect1>
		<title>Returvärden</title>

		<para>
			I funderingen ovan vore det ju bra om autentiseringen kunde
			returnera ett värde (ett boolskt värde till exempel). Det kan se
			ut så här:

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
function is_logged_in ($name, $pass) {
        return (($name == "kalle") and ($pass="ankeborg));
}
?>
]]>
				</programlisting>
			</example>

			Denna funktion är ganska kompakt och gör sig fötjänt av en
			förklaring.  Den tar två argument, $namn och $pass. Funktionen
			returnerar värdet av en boolsk operation.
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Aktuellt avsnitt i manualen.
			<ulink url="http://www.php.net/manual/en/functions.php">
				<citetitle>http://www.php.net/manual/en/functions.php</citetitle>
			</ulink>
		</para>
	</sect1>
</chapter>


<chapter>
	<title>Filer och filhantering</title>

	<abstract>
		<para>
			När man skriver datorprogram vill man ofta spara information mellan
			olika körningar program. Ett sätt att göra detta är att lagra
			informationen i en eller flera filer. I detta kapitel behandlas hur
			man gör.
		</para>
	</abstract>

	<sect1>
		<title>Filer</title>

		<para>
			Innan vi börjar använda oss av filer i programmeringen skall vi
			titta lite kort på vad en fil är. En fil är en samling
			sammanhängande information på ett medium, oftast en hårddisk,
			som man namngett.
		</para>

		<para>
			För att läsa eller skriva i filen använder man ett filhandtag
			(eng.  file handle). När man programmerar kan man inte hoppa runt
			i filen hur som helst lika enkelt som man gör i till exempel ett
			ordbehandlingsprogram.
		</para>
	</sect1>

	<sect1>
		<title>Arbetsmetod vid arbete med filer</title>

		<para>
			När man jobbar med filer i PHP använder man följande metodik.
		</para>

		<para>
			Man öppnar en fil med ett anrop till funktionen <emphasis>fopen
			</emphasis>. Den funktionen returnerar ett filhandtag. Detta
			filhandtag kan man sedan använda för att skriva till eller läsa
			från filen. Slutligen skall man stänga sin fil med funktionen
			<emphasis>fclose</emphasis>. När man har en fil öppen finns det
			också, även om man inte märker det så ofta, en så kallad filpekare
			som håller reda på var i filen man är.
		</para>
	</sect1>

	<sect1>
		<title>fopen</title>

		<para>
			Fopen är en funktion som tar två argument och returnerar ett
			filhandtag.  Så här kan ett anrop till fopen se ut:

			<example>
				<title>Indentering</title>
				<programlisting>
<![CDATA[
<?php
$filhandtag = fopen("/home/rejas/data/testfil", "a");
?>
]]>
				</programlisting>
			</example>

			Vad som sker är att $filhandtag tilldelas ett handtag till filen
			testfil i katalogen /home/rejas/data/. Observera att detta är
			sökvägen till filen på servern och att den användare som kör
			webservern måsta ha rätt att läsa och eventuellt skriva till filen.
			Det första argumentet är således filnamnet, men vad är det andra?
			Jo det andra talar om på vilket sätt filen skall öppnas. Följande
			är de vanligaste värdena på det andra argumentet och deras
			innebörder:


			<table frame='all'>
				<title>Andra argumentet till fopen</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<colspec colname='c1'/>
					<colspec colname='c2'/>

					<thead>
						<row>
							<entry>Värde</entry>
							<entry>Innebörd</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>r</entry>
							<entry>
								Öppnar en fil endast för läsning, filpekaren
								placeras först i filen.
							</entry>
						</row>
						<row>
							<entry>r+</entry>
							<entry>
								Öppnar en fil för läsning och skrivning, filpekaren
								placeras i början av filen.
							</entry>
						</row>
						<row>
							<entry>w</entry>
							<entry>
								Öppnar en fil endast för skrivning, filpekaren ställs
								ställs först i filen. Om filen inte finns skapas den
								och om den finns så blir den överskriven.
							</entry>
						</row>
						<row>
							<entry>w+</entry>
							<entry>Samma som w men öppnar även för läsning</entry>
						</row>
						<row>
							<entry>a</entry>
							<entry>
								Öppnar endast för skrivning. Skapar filen om den inte
								finns. Ställer filpekaren i slutet av filen.
							</entry>
						</row>
						<row>
							<entry>a+</entry>
							<entry>Samma som a men även för läsning.</entry>
						</row>
						<row>
							<entry>x</entry>
							<entry>
								Öppnar en fil för skrivning och placerar filpekaren i
								början av filen. Om filen redan existerar returnerar
								funktionen FALSE och ett varnings meddelande kan komma
								att skrivas ut. Annars skapas filen.
							</entry>
						</row>
						<row>
							<entry>x+</entry>
							<entry>
								Samma som x men tillåter även läsning av filen.
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			Argumenten med + till fopen verkar bra att använda men används
			faktiskt inte så ofta som man kan tro.
		</para>
	</sect1>

	<sect1>
		<title>fwrite</title>

		<para>
			fwrite är en funktion som använda för att skriva till en fil. Den
			tar två argument, ett filhandtag och så det som skall skrivas till
			filen.
		</para>

		<para>
			Ett exmpel:

			<example>
				<title>Exempel med fwrite</title>
				<programlisting>
<![CDATA[
<?php
$fh = fopen("/home/rejas/data/testfil", "a");
frite($fh, "Hej på dig\n");
fclose($fh);
?>
]]>
				</programlisting>
			</example>

			Funktionen fopen returnerar false om det skulle vara så att den
			inte kan skriva till filen så det kan vara bra att kolla att det
			går bra.

			<example>
				<title>Fwrite med felkontrol</title>
				<programlisting>
<![CDATA[
<?php
$fh = fopen("/home/rejas/data/testfil", "a");
if (! fwrite($fh, "Hej på dig\n")) {
   echo "Ooops, fel vid skrivning till fil";
   exit; // Avbryter körningen
}

fclose($fh);
?>
]]>
				</programlisting>
			</example>

			Även fopen returnerar false om den inte kan öppna filen, att kolla
			detta lämnas som övning till läsaren :).
		</para>
	</sect1>

	<sect1>
		<title>Readfile</title>

		<para>
			Readfile är en av många funktioner som kan användas för att läsa
			från en fil. Den läser en hel fil och skriver ut den på
			utskiftsbufferten.
		</para>

		<para>
			Se följande exempel:

			<example>
				<title>Exempel med readfile</title>
				<programlisting>
<![CDATA[
<?php
readfile("/home/rejas/data/testfil");
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Sammanhängande exempel</title>

		<para>
			Nu kan vi skriva ett litet program som varje gång det körs lägger
			till en rad i en fil och skriver ut filen.

			<example>
				<title>Sammanhängande exempel på filanvändning</title>
				<programlisting>
<![CDATA[
<?php
$filename = "/home/rejas/data/testfil";

$fh = fopen($filename, "a");

if (! fwrite($fh, "Hej på dig\n")) {
   echo "Ooops, fel vid skrivning till fil";
   exit; // Avbryter körningen
}

fclose($fh);

readfile($filename);
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			Mer information om funktioner för att hantera filer och filsystem
			finns hära:
			<ulink url="http://se.php.net/manual/en/ref.filesystem.php">
				<citetitle>
					http://www.php.net/manual/en/ref.filesystem.php
				</citetitle>
			</ulink>
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Arrayer (vektorer)</title>

	<abstract>
		<para>
			Vi har tidigare tittat på variabler. Nu skall vi titta på en speciell
			typ av variabler nämligen arrayer. En array är en variabel som kan
			innehålla flera olika värden. En array kallas iband även för en
			vektor.
		</para>
	</abstract>

	<sect1>
		<title>Arrayer</title>

		<para>
			Ibland vill man spara flera värden i en variabel. Till exempel om
			de måste höra ihop och inte får komma isär eller om man vill
			returnera flera världen från en funktion. Det är precis var arrayer
			är, en typ av variabel som kan hålla flera värden.
		</para>

		<para>
			Vi kastar oss direkt in på ett exempel:

			<example>
				<title>Arrayer</title>
				<programlisting>
<![CDATA[
<?php
// Vi skapar en array som heter arr och innehåller tre värden.
$arr[0] = 10;
$arr[1] = 20;
$arr[2] = 30;

echo $arr[2]; // Skriver ut 20
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>

	<sect1>
		<title>Array-funktioner</title>

		<para>
			En annan fördel med arrayer är att det finns massor av funktioner
			som verkar på arrayer. Till exempel så finns det funktioner för att
			sortera, reversera eller blanda arrayer.
		</para>

		<para>
			Vi skall titta på ett par användbara funktioner:
		</para>

			<sect2>
				<title>Funktionen array_reverse</title>

				<para>
					Den här funktionen tar en array som argument och returnerar
					samma array fast i omvänd ordning. Det vill säga det som var
					sist i arrayen tidigare liger först i den array som
					array_reverse returnerar. Ett litet exempel:

					<example>
						<title>Exempel med array_reverse()</title>
						<programlisting>
<![CDATA[
<?php
$arr[0] = 1;
$arr[1] = 2;
$arr[2] = 3;

$arr2 = array_reverse($arr);
<!--
 XXX: Varför inte använda var_dump eller print_r() ?
-->
echo $arr2[0]; // Skriver ut 3
echo $arr2[1]; // Skriver ut 2
echo $arr2[2]; // Skriver ut 1
?>
]]>
						</programlisting>
					</example>
				</para>
			</sect2>

			<sect2>
				<title>Funktionen sort</title>

				<para>
					Funktionen sort tar en array som argument och sorterar den.
					Observera att denna funktion inte returnerar något utan
					sorterar den array den får som argument.

					<example>
						<title>Exempel med sort()</title>
						<programlisting>
<![CDATA[
$arr2[0] = "Kalle";
$arr2[1] = "Fnatte";
$arr2[2] = "Knatte";
$arr2[3] = "Kajsa";
$arr2[4] = "Joakim";
$arr2[5] = "Alexander";
$arr2[6] = "Tjatte";


sort($arr2); // Observera att inget returneras, utan att arrayen blir sorterad.

for ($i = 0; $i <= 6; $i++) {
        echo "$arr2[$i]<br>";
}
]]>
					</programlisting>
					</example>
				</para>
			</sect2>

			<sect2>
				<title>Funktionen file</title>

				<para>
					File är en funktion som kanske bättre pasar bland
					filfunktionerna (där finns den till exempel i PHP-manualen)
					men jag har valt att lägga den här eftersom den inbjuder till
					att använda andra array-funktioner.
					<!--
					XXX: Den bör nog flyttas iaf till rätt sektion vars den *ska*
					     vara ;)
					-->
				</para>

				<para>
					File tar ett argument som skall vara ett filnamn, den
					returnerar en array med varje rad i filen i ett element.
				</para>
			</sect2>
	</sect1>

	<sect1>
		<title>Mer läsning</title>

		<para>
			http://www.php.net/manual/en/language.types.array.php
			http://www.php.net/manual/en/ref.array.php
		</para>
	</sect1>
</chapter>

<chapter>
	<title>Mer om funktioner</title>

	<abstract>
		<para>
			Tidigare har vi lärt oss hur funktioner fungerar. I detta kapitel
			lär vi oss lite mer om dem.
		</para>
	</abstract>


	<sect1>
		<title>Call by reference, call by value</title>

		<para>
			När man anropar en funktion skickar man vanligtvis med ett eller
			flera argument. Vi har tidigare sett att om man ändrar dessa argument
			i funktionen så ändras de inte utanför funktionen. Det är för att man
			lättare skall kunna flytta funktionen mellan olika program utan att
			behöva vara rädd för att den skall ändra något utanför själva
			funktionen. Detta kallas för <emphasis>call by value</emphasis>. Det
			vill säga att värdet i variabeln skickas till funktionen, inte själva
			variabeln.
		</para>

		<para>
			Ibland kan man vilja låta funktionen ändra variabler även i världen
			utanför. Alltså om jag skickar en variabel till en funktion och den
			ändras i funktionen så skall den ändras även utanför funktionen.
			Detta förfarande kallas för <emphasis>call by reference</emphasis>.
			Det vill säga att man istället för att skicka en kopia på värdet i en
			variabel så skickar man en pekare till variablen så att det man gör
			men variabeln i funktionen även händer utanför funktionen.
		</para>

		<para>
			Detta kan i flera fall vara väldigt smidigt men skall normalt
			undvikas. Ett litet exempel.

			<example>
				<title>Call by reference</title>
				<programlisting>
<![CDATA[
<?php
function swap (&$var1, &$var2) {
   $tmp = $var2;
   $var2 = $var1;
   $var1 = $tmp;
}

$text1 = "Text1";
$text2 = "Text2";

swap($text1, $text2);

echo "$text1, $text2\n";
?>
]]>
				</programlisting>
			</example>
		</para>
	</sect1>
</chapter>


<chapter>
	<title>Inmatning</title>

	<abstract>
		<para>
			Kommer ...
		</para>
	</abstract>

</chapter>

&dtr1207;

&dtr1208;

&fdl-sv;



</book>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
tab-width: 3
End:
vim600: syn=xml fen fdm=syntax si
vim: noet sw=3 ts=3 syn=sgml
vi: ts=3 sw=3
-->
